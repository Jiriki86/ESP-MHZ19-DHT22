use anyhow::Result;
use embedded_svc::mqtt::client::QoS;
use esp_idf_svc::hal::delay::Delay;
use esp_idf_svc::hal::{
    gpio::AnyIOPin, gpio::PinDriver, peripherals::Peripherals, prelude::*, uart,
};
use esp_idf_svc::mqtt::client::{EspMqttClient, MqttClientConfiguration};
use std::{thread::sleep, time::Duration};

use embedded_hal::digital::{OutputPin, PinState};

mod wifi;
use crate::wifi::wifi;
use esp_idf_svc::eventloop::EspSystemEventLoop;

mod dht22;
use dht22::Dht22;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
    #[default("localhost")]
    mqtt_host: &'static str,
    #[default("")]
    mqtt_user: &'static str,
    #[default("")]
    mqtt_pass: &'static str,
}

fn main() -> Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    log::info!("ESP started");

    let peripherals = Peripherals::take().unwrap();

    // lets blink an LED while we are running
    let mut led_pin = PinDriver::output(peripherals.pins.gpio2);

    // configure a uart port to read the co2 sensor data
    let config = uart::config::Config::default().baudrate(Hertz(9600));

    let uart: uart::UartDriver = uart::UartDriver::new(
        peripherals.uart1,
        peripherals.pins.gpio33,
        peripherals.pins.gpio32,
        Option::<AnyIOPin>::None,
        Option::<AnyIOPin>::None,
        &config,
    )
    .unwrap();

    // sleep before talking to dht22 for first time
    sleep(Duration::from_millis(100));

    // get io pin to talk to dht22
    let delay = Delay::new_default();
    let dht22_pin = PinDriver::input_output_od(peripherals.pins.gpio4).unwrap();
    let mut dht22 = Dht22::new(delay, dht22_pin);

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Connect to the Wi-Fi network
    let sysloop = EspSystemEventLoop::take()?;
    let wifi = wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sysloop,
    )?;

    let broker_url = format!(
        "mqtt://{}:{}@{}",
        app_config.mqtt_user, app_config.mqtt_pass, app_config.mqtt_host
    );
    let mqtt_config = MqttClientConfiguration::default();
    let mut client = EspMqttClient::new(&broker_url, &mqtt_config, move |_message_event| {
        // left empty on purpose
    })?;

    loop {
        let wifi_connected = wifi.is_connected();
        match wifi_connected {
            Ok(conn) => {
                let state = if conn { PinState::High } else { PinState::Low };
                led_pin.as_mut().unwrap().set_state(state)?;
            }
            Err(err) => log::warn!("Wifi not connected {}", err),
        }

        // read co2 concentration
        // TODO: create library for sensor
        uart.write(&[0xFF, 0x1, 0x86, 0, 0, 0, 0, 0, 0x79]).unwrap();
        let mut response: [u8; 9] = [0; 9];
        uart.read(&mut response, 500).unwrap();
        let co2 = ((response[2] as i32) << 8) + response[3] as i32;
        let co2_msg = format!("{{location: \"esp-bedroom\", co2: {:}}}", co2);
        let publ_status =
            client.publish("home/data/co2", QoS::AtLeastOnce, false, co2_msg.as_bytes());
        match publ_status {
            Ok(_) => {}
            Err(err) => log::warn!("error publishing co2 data: {:}", err),
        };

        // read temperature and humidity
        let hum_and_temp = dht22.read();
        match hum_and_temp {
            Ok(val) => {
                let ambient_data_msg = format!(
                    "{{temperate: {:}, humidity: {:}, pressure: {:}, location: \"esp-bedroom\"}}",
                    val.temperature(),
                    val.humidity(),
                    0
                );
                let publ_status = client.publish(
                    "home/data/climate",
                    QoS::AtLeastOnce,
                    false,
                    ambient_data_msg.as_bytes(),
                );
                match publ_status {
                    Ok(_) => {}
                    Err(err) => log::warn!("error publishing climate data: {:}", err),
                };
            }
            Err(err) => log::warn!("{}", err),
        }

        sleep(Duration::from_millis(2500));
    }
}
