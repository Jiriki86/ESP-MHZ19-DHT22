use anyhow::Result;
use embedded_svc::mqtt::client::QoS;
use esp_idf_svc::hal::delay::Delay;
use esp_idf_svc::hal::{
    gpio::AnyIOPin, gpio::PinDriver, peripherals::Peripherals, prelude::*, uart,
};
use esp_idf_svc::mqtt::client::{EspMqttClient, MqttClientConfiguration};
use std::{thread::sleep, time::Duration};

use embedded_hal::digital::{OutputPin, PinState};

mod wifi;
use crate::wifi::wifi;
use esp_idf_svc::eventloop::EspSystemEventLoop;

mod dht22;
use dht22::Dht22;

mod mh_z19;
use mh_z19::MHz19;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
    #[default("localhost")]
    mqtt_host: &'static str,
    #[default("")]
    mqtt_user: &'static str,
    #[default("")]
    mqtt_pass: &'static str,
}

fn main() -> Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    log::info!("ESP started");

    let peripherals = Peripherals::take().unwrap();

    // lets blink an LED while we are running
    let mut led_pin = PinDriver::output(peripherals.pins.gpio2);

    // configure a uart port to read the co2 sensor data
    let config = uart::config::Config::default().baudrate(Hertz(9600));

    let uart: uart::UartDriver = uart::UartDriver::new(
        peripherals.uart1,
        peripherals.pins.gpio33,
        peripherals.pins.gpio32,
        Option::<AnyIOPin>::None,
        Option::<AnyIOPin>::None,
        &config,
    )
    .unwrap();
    let mut mhz19 = MHz19::new(uart);
    mhz19.enable_auto_calibration(true)?;

    // sleep before talking to dht22 for first time
    sleep(Duration::from_millis(100));

    // get io pin to talk to dht22
    let delay = Delay::new_default();
    let dht22_pin = PinDriver::input_output_od(peripherals.pins.gpio4).unwrap();
    let mut dht22 = Dht22::new(delay, dht22_pin);

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Connect to the Wi-Fi network
    let sysloop = EspSystemEventLoop::take()?;
    let wifi = wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sysloop,
    )?;

    let broker_url = format!(
        "mqtt://{}:{}@{}",
        app_config.mqtt_user, app_config.mqtt_pass, app_config.mqtt_host
    );
    let mqtt_config = MqttClientConfiguration::default();
    let mut client = EspMqttClient::new(&broker_url, &mqtt_config, move |_message_event| {
        // left empty on purpose
    })?;

    // first value is usually broken
    let _ = mhz19.read_co2();

    loop {
        println!("Reading data");
        let wifi_connected = wifi.is_connected();
        match wifi_connected {
            Ok(conn) => {
                let state = if conn { PinState::High } else { PinState::Low };
                led_pin.as_mut().unwrap().set_state(state)?;
            }
            Err(err) => log::warn!("Wifi not connected {}", err),
        }

        // read co2 concentration
        let co2_result = mhz19.read_co2();
        match co2_result {
            Ok(co2) => {
                let co2_msg = format!("{{\"location\": \"esp-bedroom\", \"co2\": {:}}}", co2);
                let publ_status =
                    client.publish("home/data/co2", QoS::AtLeastOnce, false, co2_msg.as_bytes());
                match publ_status {
                    Ok(_) => {}
                    Err(err) => log::warn!("error publishing CO2 data: {:}", err),
                };
            }
            Err(err) => log::warn!("error reading CO2 data: {:}", err),
        }

        // read temperature and humidity
        let hum_and_temp = dht22.read();
        match hum_and_temp {
            Ok(val) => {
                let ambient_data_msg = format!(
                    "{{\"temperature\": {:}, \"humidity\": {:}, \"pressure\": {:}, \"location\": \"esp-bedroom\"}}",
                    val.temperature(),
                    val.humidity(),
                    0
                );
                let publ_status = client.publish(
                    "home/data/climate",
                    QoS::AtLeastOnce,
                    false,
                    ambient_data_msg.as_bytes(),
                );
                match publ_status {
                    Ok(_) => {}
                    Err(err) => log::warn!("error publishing climate data: {:}", err),
                };
            }
            Err(err) => log::warn!("{}", err),
        }

        sleep(Duration::from_millis(5 * 60 * 1000));
    }
}
